# 通过一个例子了解泛型
实例：`ArrayList` 实现任意对象的数组形式存储

详见：https://www.liaoxuefeng.com/wiki/1252599548343744/1265102638843296

# 接口泛型

实例：实现自定义对象 `Person` 的排序

详见：`App.java` 和 `Person.java`

# 编写泛型

实例：单个泛型类型和多个泛型类型的编写

详见：`App.java` 和 `Pair.java`

# 总结

- 从功能上来说，泛型是一个模板。它的优点是避免了强制类型转换，而类型的正确性交由编译器检查。
- 泛型之间具有继承关系：可以把`ArrayList<Integer>`（ `ArrayList<T>`） 向上转型为`List<Integer>`（`List<T>`） ，而不能把 `ArrayList<Integer>` 向上转型为 `ArrayList<Number>`（理解：Number 这个“篮子”中必须装同一种子类的对象，不然取数时就容易使用错误的引用类型）
- 可以在接口中定义泛型，实现此接口的类必须实现正确的泛型类型。
- 可以省略编译器能自动推断出的类型（建议不要省略），例如：`List<String> list = new ArrayList<>();`
- 不指定泛型类型时，编译器默认将其视为 `Object` 类型。
- **泛型类型必须是引用类型**
- 编写泛型
    - 可以根据一个类改写成泛型类，需要定义泛型类型`<T>`
    - 静态方法的泛型类型不能和类中其他方法和字段的泛型类型一样，除此之外，还需要在 `static` 后加上泛型类型

