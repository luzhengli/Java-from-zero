# 运算
相比于整型数，浮点数只能进行基本四则运算。

# 浮点数是不精确的
计算机中浮点数可能无法精确表示。例如`0.1`的二进制是无限循环的，因此没法精确存储，但`0.5`这个浮点数可以精确存储。

基于上述原因，浮点数运算可能产生误差。具体可见`Instance.java`

由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。**正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数**（可见`Instance.java`）

浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循 [IEEE-754](https://web.archive.org/web/20070505021348/http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html) 标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。

# 类型提升（自动类型转换）
整数与浮点数的运算中，整数类型会自动转为浮点数类型。

例1：
```java
int n = 5;
double d = 1.2 + 24.0 / n; // 6.0
```
输出：6.0

例2：
```java
double d = 1.2 + 24 / 5; // 5.2
```
输出：5.2

**注**：两个整数的运算，不会产生类型提升。

# 强制类型转换
可以将浮点数强制转型为整数。

**转换规则**：
- 浮点数的**小数部分会被舍弃**（不是四舍五入）。
- 转型后超过了整型能表示的最大范围，将返回整型的最大值。
```java
int n1 = (int) 12.3; // 12
int n2 = (int) 12.7; // 12
int n2 = (int) -12.7; // -12
int n3 = (int) (12.7 + 0.5); // 13
int n4 = (int) 1.2e20; // 2147483647
```

tip：如果希望强制类型转换时进行四舍五入，可以加上`0.5`。

例如：
```java
int n = (int)(1.6 + 0.5);
```