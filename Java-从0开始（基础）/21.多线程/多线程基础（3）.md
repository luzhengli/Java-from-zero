# 线程池

## 基本用法

Java标准库提供了`ExecutorService`接口表示线程池，它的典型用法如下：

```java
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
```

因为`ExecutorService`只是`Interface`，Java标准库提供的几个常用实现类有：

-   FixedThreadPool：线程数固定的线程池；
-   CachedThreadPool：线程数根据任务动态调整的线程池；
-   SingleThreadExecutor：仅单线程执行的线程池。



**实例**：以 FixedThreadPool 为例，了解线程池的运作逻辑

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class App {
    public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(4); // 创建一个固定大小的线程池
        for (int i = 0; i < 6; i++) {
            es.submit(new Task("" + i)); // 提交任务
        }
        es.shutdown(); // 关闭线程池
    }
}

class Task implements Runnable { // 定义Task类（实现Runnable接口）
    private final String name;

    public Task(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println("start task " + name);
        try {
            Thread.sleep(1000); // 等待1s
        } catch (InterruptedException e) {
            System.out.println(e);
        }
        System.out.println("end task " + name);
    }
}
```

输出（结果不稳定）：

```cmd
start task 0
start task 2
start task 3
start task 1
end task 1
end task 0
end task 2
end task 3
start task 5
start task 4
end task 5
end task 4
```

分析：一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。



小结：**使用线程池的主要步骤**可分为三块

1.  创建线程池
    1.  有多种可供选择线程池（例如：ExecutorService es = Executors.newFixedThreadPool(4); // 创建一个固定大小的线程池）
2.  启动任务（要先定义好任务类Task，需实现 `Runnable` 接口）
    1.  `ExecutorService.summit(Task)`
3.  关闭线程池
    1.  `shutdown()`：等待正在执行的任务先完成，然后再关闭
    2.  `shutdownNow()`：立刻停止正在执行的任务
    3.  `awaitTermination()`：等待指定的时间让线程池关闭



## ScheduledThreadPool

有些任务需要反复的执行，例如每秒刷新股票价格。这可以通过 ScheduledThreadPool 实现。



ScheduledThreadPool 的使用流程：

1.  创建 ScheduledThreadPool

    1.  `ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);`

2.  执行任务（方式有多种）

    1.  一次性任务，在指定延时后执行一次

        ```java
        // 1秒后执行一次性任务:
        ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);
        ```

    2.  周期性任务，按固定时间间隔触发（相邻任务的开始时刻的时间间隔是一样的）

        ```cmd
        时序图
        --------------------------------------
        │░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
        ├───────┼───────┼───────┼───────┼────>
        │<─────>│<─────>│<─────>│<─────>│
        ```

        ```java
        // 实例
        ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS); // 2秒后开始执行定时任务，每3秒执行
        ```

    3.  周期性任务，等待固定时间间隔触发（相邻任务，前面任务的结束时刻到后面任务的开始时刻的时间间隔是一样的）

        ```cmd
        时序图
        -------------------------------------
        │░░░│       │░░░░░│       │░░│       │░
        └───┼───────┼─────┼───────┼──┼───────┼──>
            │<─────>│     │<─────>│  │<─────>│
        ```

        ```java
        // 实例
        ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS); // 2秒后开始执行定时任务，以3秒为间隔执行
        ```



---

思考：

>   Q1:在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？
>
>   A1:If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.
>
>   译：如果此任务的任何执行时间超过其周期，则**后续执行可能会延迟开始，但不会并发执行。**
>
>   
>
>   Q2:如果任务抛出了异常，后续任务是否继续执行？
>
>   A2：If any execution of the task encounters an exception, subsequent executions are suppressed. 
>
>   译：如果任务的任何执行遇到异常，则将**禁止后续任务的执行。**





# 小结

1.  线程池
    1.  Java 的 `java.util.concurrent` 提供了线程池的功能
    2.  Java 的线程池接口是 `ExecutorService`，它的具体类有：FixedThreadPool、CachedThreadPool、CachedThreadPool、ScheduledThreadPool。
    3.  线程池的使用流程主要有三步
        1.  创建具体的线程池
        2.  执行任务（要定义好任务类，需要实现 `Runnable` 接口）
        3.  关闭线程池
    4.  ScheduledThreadPool 是一种比较特别的线程池，主要用于执行周期性任务。

