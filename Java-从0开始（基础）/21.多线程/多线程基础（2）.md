# 使用 ReentrantLock 和 Condition

>   synchronized 与 `wait()`、`notify()`/ `notifyAll()` 方法可以实现多线程的竞争以及协调。
>
>   Java 提供的 ReentrantLock 与 Condition（含有`await()` 、`signal()` / `signalAll()` 方法）可以实现类似上面组合实现的功能。

>   从Java 5开始，引入了一个高级的处理并发的`java.util.concurrent`包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。
>
>   `java.util.concurrent.locks`包提供的`ReentrantLock`可用于替代`synchronized`加锁

## 如何使用 ReentrantLock？

使用 ReentrantLock 的**主要流程**：

1.  创建 ReentrantLock 锁对象（用接口 Lock 引用它）
2.  上锁（`lock()`方法）
3.  解锁（`unlock()`方法）



**实例**：在 \`多线程基础（1）.md\`中，通过 synchronized 实现的加法器写法如下

```java
class Counter {
    private volatile int counter = 0;

    public int getCounter() {
        return counter;
    }

    public synchronized void add(int n) { // 
        counter += n;
    }
}
```



使用 ReentrantLock，上述代码可以改写为：

```java
class newCounter {
    private volatile int counter = 0;
    private final Lock lock = new ReentrantLock(); // 创建ReentrantLock锁对象

    public int getCounter() {
        return counter;
    }

    public void add(int n) {
        lock.lock(); // 上锁
        try {
            counter += n;
        } finally {
            lock.unlock(); // 解锁
        }
    }
}
```





## ReentrantLock 相较于 synchronized 有何优势？

与 synchronized 不同的是，**ReentrantLock 能够尝试获取锁，可以避免 synchronized 可能导致的死锁问题**。具体需要**通过 `tryLock()`方法实现**。



实例：尝试获取锁，最多等待1s，如果超时仍未获得锁，`tryLock()` 返回 false。

```java
public void add(int n) throws InterruptedException {
    if (lock.tryLock(1, TimeUnit.SECONDS)) { // 尝试获取锁 tryLock方法必须处理或抛出InterruptedException异常
        try {
            counter += n;
        } finally {
            lock.unlock(); // 解锁
        }
    }
}
```



## 如何使用 Condition ？

Condition 提供的`await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：

-   `await()`：释放当前锁，进入等待状态；
-   `signal()`：唤醒某个等待线程；
-   `signalAll()`：唤醒所有等待线程；
-   唤醒线程从`await()`返回后需要重新获得锁。



**实例**：以 \`多线程基础（1）.md\` 中的任务出对入队为例，通过 ReentrantLock 和 Condition 机制实现的代码如下

```java
class TaskQueue {
    private final Lock lock = new ReentrantLock(); // 创建Lock实例
    private Condition condition = lock.newCondition(); // 创建一个与Lock绑定的实例condition
    private Queue<String> q = new LinkedList<>();

    public void addTask(String s) {
        lock.lock();
        try {
            q.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public String getTask() throws InterruptedException {
        lock.lock();
        try {
            while (q.isEmpty()) {
                condition.await();
            }
            return q.remove();
        } finally {
            lock.unlock();
        }
    }
}
```









## Condition 相较于 wait()/notifyAll() 有何优势？

类似 `tryLock()`，等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，线程可以自己醒来，即 `await()` 可以在等待指定时间后自动返回。这避免了线程忘记被唤醒。



示例：

```java
if (condition.await(1, TimeUnit.SECOND)) {
    // 被其他线程唤醒
} else {
    // 指定时间内没有被其他线程唤醒
}
```

# 小结

1.  使用 ReentrantLock 和 Condition

    1.  ReentrantLock 可以代替 synchronized 实现线程同步，它的使用可分为三步：
        1.  创建 ReentrantLock 锁对象（用接口 Lock 引用它）
        2.  上锁（`lock()`方法）
        3.  解锁（`unlock()`方法）
    2.  ReentrantLock 可以尝试获取锁（通过 `tryLock()` 方法实现），这就避免了死锁问题。这是它相较于 synchronized 的一个优势
    3.  Condition 提供 `await()` 和 `sinal()`/ `signalAll()` 方法可以实现线程的协调，这几个方法的使用类似 `wait()` 、`notify()`/ `notifyAll()` 方法
    4.  类似 `tryLock()`，等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，线程可以自己醒来

    

