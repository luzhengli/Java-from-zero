# 多进程和多线程的优缺点

进程和线程是包含关系，但是多任务有三种形式：

1.  多进程模式（每个进程只有一个线程）：

```ascii
┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
```

2.  多线程模式（一个进程有多个线程）：

```ascii
┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
```

3.  多进程＋多线程模式（复杂度最高）：

```ascii
┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
```



具体采用哪种方式，要考虑到进程和线程的特点

和多线程相比，**多进程的缺点**在于：

-   创建进程比创建线程开销大，尤其是在Windows系统上；
-   进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而**多进程的优点**在于：

-   多进程稳定性比多线程高，因为在**多进程的情况下，一个进程崩溃不会影响其他进程**，而在**多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃**



# Java 的多线程

Java语言内置了多线程支持：**一个Java程序实际上是一个 JVM 进程，JVM 进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程**。此外，JVM 还有负责垃圾回收的其他工作线程等。

因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。



**多线程编程的特点**：多线程经常需要**读写共享数据**，并且需要**同步**。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。



**Java多线程编程的特点**：

-   多线程模型是 Java 程序最基本的并发模型；
-   后续读写网络、数据库、Web开发等都依赖Java多线程模型。



# 创建线程

```java
public class App {
    public static void main(String[] args) throws Exception { // 主线程启动main函数 main函数可以再创建线程
        // 1. 创建线程：方法一（继承Thread类）
        Thread t1 = new MyThread(); // 创建新线程（要覆写run方法）
        t1.start(); // start()方法会在内部自动调用实例的run()方法

        // 2. 创建线程：方法二（传入Runnable对象）
        Thread t2 = new Thread(new MyRunnable());
        t2.start();

        // 3. 创建线程：方法三（lambda语句）
        Thread t3 = new Thread(()->{
            System.out.println("start a new thread3.");
        });
        t3.start();
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println("start a new thread1."); 
    }
}

class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println("start a new thread2.");
    }
}
```

输出：

```cmd
start a new thread1.
start a new thread2.
start a new thread3.
```



---

**线程之间可以相对独立的执行代码**：

多线程代表新创建的线程与主线程（main）是可以并发的，下面有个例子可以体现这点：

```java
import java.io.PrintStream;

public class App {
    public static void main(String[] args) throws Exception { 
        PrintStream out = System.out;
        out.println("start main...");
        Thread t = new Thread() {
            public void run() {
                out.println("start t...");
                try {
                    Thread.sleep(20); // 暂停当前线程一段时间 参数的单位是毫秒
                } catch (InterruptedException e) {
                }
                out.println("end t.");
            }
        };
        t.start();
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }
        out.println("end main...");
    }
}
```

输出：

```cmd
start main...
start t...
end main...
end t.
```

可以看到，线程 main 和 线程 t 所要执行的代码与其在程序中出现的位置没有必然关系。在这个例子中只能保证出现次序：

-   start main > end main
-   start t > end t



# 线程的优先级

-   线程具有优先级
-   对于优先级较高的线程，操作系统可能会调度的更频繁
-   高优先级无法保证一定先被调度，线程的调度顺序是由操作系统决定的



Java 中，设置线程的优先级的代码如下：

```java
Thread.setPriority(int n) // 1~10, 默认值5
```



# 线程的状态

## Java 线程的基本状态

Java线程的状态有以下几种：

-   New：新创建的线程，尚未执行；
-   Runnable：运行中的线程，正在执行`run()`方法的Java代码；
-   Blocked：运行中的线程，因为某些操作被阻塞而挂起；
-   Waiting：运行中的线程，因为某些操作在等待中；
-   Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；
-   Terminated：线程已终止，因为`run()`方法执行完毕



状态转移图表示如下：

```cmd
         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
```

-   线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。



## 线程终止的原因

1.  正常终止：`run()`方法执行到`return`语句（没有return返回`null`）返回
2.  意外终止：`run()`方法因为未捕获的异常导致线程终止
3.  强制终止：对某个线程的`Thread`实例调用`stop()`方法（不推荐使用！！）



---

**一个线程还可以等待另一个线程直到其运行结束，通过 `Thread.join()` 方法实现**。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：

```java
PrintStream out = System.out;
out.println("start main...");
Thread t = new Thread() {
	public void run() {
	out.println("start t...");
	out.println("end t.");
	}
};
t.start();
t.join();
out.println("end main...");
```

输出：

```cmd
start main...
start t...
end t.
end main...
```

-   如果`t`线程已经结束，对实例`t`调用`join()`会立刻返回
-   `join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。

# 中断线程

## 什么是中断线程？

>   中断线程不代表立即终止线程。这里的中断指的是外部线程A向另一个线程B发送了中断请求信号。线程B可以选择接受中断信号，执行相应的代码，当然也可以不接受！

中断线程是指 其他线程给该线程发一个**信号**，该线程收到信号后结束执行`run()`方法，使得自身线程能立刻结束运行。



例子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。



## 如何中断线程？

**方法一**：在其他线程中对目标线程调用`interrupt()`方法，目标线程需要反复检测自身状态是否是 interrupted 状态，如果是，就立刻结束运行。



实例：

```java
import java.io.PrintStream;

public class App {
    public static void main(String[] args) throws InterruptedException { // 主线程启动main函数 main函数可以再创建线程
        // 中断线程
        PrintStream out = System.out;
        out.println("start main...");
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1);
        t.interrupt(); // main线程请求t线程中断
        t.join();
        out.println("end main.");  
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        int n = 0;
        while (!isInterrupted()){ // isInterrupted()方法响应中断请求
            n++;
            System.out.println(n + "hello.");
        }
    }
}
```

输出：

```cmd
start main...
1hello.
2hello.
3hello.
end main.
```

-   `System.out.println(n + "hello."); ` 语句输出次数不确定



---

**注意**：如果 a 线程在等待某一线程 b 结束时（`b.join()`），有一个线程请求 a 线程中断，那么此时 `b.join()` 方法会立即抛出 `InterruptedException` 异常。



实例：

```java
public class App {
    public static void main(String[] args) throws InterruptedException { 
        Thread t = new MyThread(); // 创建t线程
        t.start(); // 启动t线程
        Thread.sleep(1000); // 主线程等待1s
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println("end");
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        // 等待hello线程结束-请求中断hello线程
        Thread hello = new HelloThread(); // 创建hello线程
        hello.start(); // 启动hello线程
        try {
            hello.join(); // t线程等待hello线程结束
        } catch (InterruptedException e) { // t线程等待hello线程结束的过程中有其他线程请求中断t线程时 抛出InterruptedException异常
            System.out.println("hello interrupted!");
        }
        hello.interrupt(); // t线程中断前申请中断hello线程
    }
}

class HelloThread extends Thread {
    public void run() {
        // 打印-等待0.1s
        int n = 0;
        while (!isInterrupted()) { // hello接收到t的中断请求后结束while循环
            n++;
            System.out.println(n + " hello!");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
```

输出：

```cmd
1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
hello interrupted!
end
```



---

**方法二**：用一个**`running`标志位**来标识线程是否应该继续运行，在外部线程中，通过把`Thread.running`置为`false`，就可以让线程结束



实例：

```java
public class App {
    public static void main(String[] args) throws InterruptedException { 
        HelloThread hello = new HelloThread();
        hello.start();
        Thread.sleep(1); // 这里让主进程main等待一会是为了让hello进程有空打印一些内容 不至于马上就中断退出
        hello.running = false; // 设置标志为false 相当于申请hello中断
    }
}

class HelloThread extends Thread {
    public volatile boolean running = true; // 线程间共享变量使用 volatile 关键字标识

    @Override
    public void run() {
        int n = 0;
        while (running) { // 查询中断标志位 中断标志为true前执行while语句
            n++;
            System.out.println(n + " hello!");
        }
        System.out.println("end hello.");
    }
}
```



**使用 `volatile` 关键字的目的**是告诉虚拟机

-   每次访问变量时，总是获取主内存的最新值；
-   每次修改变量后，立刻回写到主内存

即，`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。

注：这里涉及到 **Java 的内存模型**，这部分等到以后再深入。

# 小结

-   创建线程
    -   使用 Thread 类创建线程对象，调用其 `start()` 方法启动线程（且最多仅能调用一次）
    -   线程要执行的代码编写在其 `run()` 函数中，因此需要对该方法进行重写
    -   使用静态方法 `Thread.sleep()` 可以暂停线程指定的时间，参数的单位是毫秒
-   线程的优先级
    -   线程调度由操作系统决定，程序无法决定调度顺序
    -   可以设置线程的优先级，优先级越高的线程更容易被频繁的调度
-   线程的状态
    -   新创建未执行：new
    -   中间的几种可互相转换的状态：Runnable、Blocked、Waiting 和 Timed Waiting
    -   线程已终止：Terminated
-   线程终止
    -   原因
        -   正常终止（`run()`方法中的代码正常执行并返回）
        -   意外终止（线程抛出异常）
        -   强制终止（使用`stop()`方法）
    -   等待一个线程的结束：使用`join()` 方法
-   中断线程的两种方法
    1.  调用希望中断的线程的 `interrupt() ` 方法
        -   目标线程调用 `interrupt()` 方法可以请求该线程中断
        -   在目标线程的 `run()` 方法中检测 `isInterrupted()` 标志获取自身是否中断
        -   如果目标线程处在等待状态（调用 `join()` 方法），又收到了中断请求，此时 `join()` 方法会立即抛出 `InterruptedException` 异常，这时需要对其进行捕获
    2.  使用标志位：用一个**`running`标志位**来标识线程是否应该继续运行，在外部线程中，通过把`Thread.running`置为`false`，就可以让线程结束
        -   标志位判断需要正确使用`volatile`关键字，`volatile`关键字解决了共享变量在线程间的可见性问题

